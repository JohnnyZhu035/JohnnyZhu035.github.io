<!doctypehtml><html class="theme-next pisces use-motion" lang=zh-Hans><meta charset=UTF-8><meta content=IE=edge http-equiv=X-UA-Compatible><meta content=width=device-width,initial-scale=1,maximum-scale=1 name=viewport><meta content=#222 name=theme-color><script src=/lib/pace/pace.min.js></script><link href=/lib/pace/.min.css?v=1.0.2 rel=stylesheet><meta content=no-transform http-equiv=Cache-Control><meta content=no-siteapp http-equiv=Cache-Control><link href=/lib/font-awesome/css/font-awesome.min.css?v=4.6.2 rel=stylesheet><link href=/css/main.css?v=6.0.0 rel=stylesheet><link href=/images/apple-touch-icon-next.png?v=6.0.0 rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png?v=6.0.0 rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png?v=6.0.0 rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg?v=6.0.0 rel=mask-icon><meta content="Hexo, NexT" name=keywords><meta content=website property=og:type><meta content=Reading-Paper property=og:title><meta content=https://johnnyzhu035.github.io/tags/index.html property=og:url><meta content="JohnnyZhu's HomePage!" property=og:site_name><meta property=og:locale><meta content=2024-07-18T09:23:47.000Z property=article:published_time><meta content=2024-07-18T09:38:55.907Z property=article:modified_time><meta content=Johnny property=article:author><meta content=summary name=twitter:card><script id=hexo.configurations>var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };</script><link href=https://JohnnyZhu035.github.io/tags/ rel=canonical><title>Reading Paper:Belief-selective Propagation Detection for MIMO Systems | JohnnyZhu's HomePage!</title><meta content="Hexo 7.3.0" name=generator><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container sidebar-position-left page-post-detail"><div class=headband></div><header class=header id=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-wrapper><div class=site-meta><div class=custom-logo-site-title><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <span class=site-title>JohnnyZhu's HomePage!</span> <span class=logo-line-after><i></i></span> </a></div><p class=site-subtitle>An undergraduate student in Southeast University Chien-Shiung Wu College</div><div class=site-nav-toggle><button><span class=btn-bar></span> <span class=btn-bar></span> <span class=btn-bar></span></button></div></div><nav class=site-nav><ul class=menu id=menu><li class="menu-item menu-item-home"><a href=/ rel=section> <i class="menu-item-icon fa fa-fw fa-home"></i> <br> 首页 </a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section> <i class="menu-item-icon fa fa-fw fa-tags"></i> <br> 标签 </a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section> <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br> 归档 </a><li class="menu-item menu-item-search"><a class=popup-trigger href=javascript:;> <i class="menu-item-icon fa fa-search fa-fw"></i> <br> 搜索 </a></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon> <i class="fa fa-search"></i> </span><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span><div class=local-search-input-wrapper><input autocomplete=off id=local-search-input placeholder=搜索... spellcheck=false></div></div><div id=local-search-result></div></div></div></nav></div></header><main class=main id=main><div class=main-inner><div class=content-wrap><div class=content id=content><div class=posts-expand id=posts><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><div class=post-block><link href=https://JohnnyZhu035.github.io/2024/07/14/Reading-Paper-Belief-selective-Propagation-Detection-for-MIMO-systems/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta itemprop=name> <meta itemprop=description> <meta content=/images/avatar.png itemprop=image> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="JohnnyZhu's HomePage!" itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Reading Paper:Belief-selective Propagation Detection for MIMO Systems</h1><div class=post-meta><span class=post-time> <span class=post-meta-item-icon> <i class="fa fa-calendar-o"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2024-07-14T21:50:08+08:00 title=创建于>2024-07-14</time> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon> <i class="fa fa-calendar-check-o"></i> </span> <span class=post-meta-item-text>更新于:</span> <time datetime=2024-07-18T15:20:47+08:00 itemprop=dateModified title=更新于>2024-07-18</time> </span><span class=post-comments-count> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon> <i class="fa fa-comment-o"></i> </span> <a href=/2024/07/14/Reading-Paper-Belief-selective-Propagation-Detection-for-MIMO-systems/#comments itemprop=discussionUrl> <span class="post-comments-count disqus-comment-count" data-disqus-identifier=2024/07/14/Reading-Paper-Belief-selective-Propagation-Detection-for-MIMO-systems/ itemprop=commentCount></span> </a> </span><div class=post-wordcount><span class=post-meta-item-icon> <i class="fa fa-clock-o"></i> </span><span title=阅读时长>12 mins.</span></div></div></header><div class=post-body itemprop=articleBody><h2 id=Prerequisites><a class=headerlink href=#Prerequisites title=Prerequisites></a>Prerequisites</h2><p>$\quad$For a first year student who have been arranged to not take courses like <em>probability theory</em>,the famed Bayesian things are not familiar to me at all.So I prepare some prerequisite knowledge here!<h3 id=Bayes’-theorem><a title="Bayes’ theorem" class=headerlink href=#Bayes’-theorem></a>Bayes’ theorem</h3><p>$\quad$In this theorem,we define two events $A$ and $B$,each having $P(A),P(B)$ to denote their possibilities of happening.The Bayes’ theorem considers the influence on the possibilities of each other.We denote event that if B happens,A also happens using $A|B$.<br>The Bayes’ theorem tells us that<blockquote><p>$P(A|B)=\frac{P(B|A)P(A)}{P(B)}$</blockquote><p>we give each possibility in this formula<br>a name:<blockquote><p>$P(A)$ is $A$’s prior probability(which means it does not take any related event into account,only considering the general case)<br>$P(A|B)$ is $A$’s posterior probability(which means that after B happens,the possibility that A happens should be refreshed)</blockquote><h3 id=Maximum-Likelihood-Estimate-MLE><a title="Maximum Likelihood Estimate(MLE)" class=headerlink href=#Maximum-Likelihood-Estimate-MLE></a>Maximum Likelihood Estimate(MLE)</h3><p>$\quad$For a random test(like flipping coins)<br>define the possibility of event <em>Heads</em> $\theta$,then event <em>Tails</em> is defined as $(1-\theta)$.in one test,<em>Heads</em> happen $a$ times and <em>Tail</em> happen $b$ times.We define the possibilty that this test happens as $N$.Define the possibility $P(N|\theta)$as the <em>likelihood function</em> $L(\theta)$:<blockquote><p>$L(\theta)=\theta^a*(1-\theta)^b$</blockquote><p>where we need to find the most possible point to let the function have its extreme point.Take the logarithm on both sides of the function equation:<blockquote><p>$\log{(L(\theta))}=a\log{(\theta)}+b\log{(1-\theta)}$</blockquote><p>take the derivative of it,we can easily get the extreme point!<h3 id=Maximum-a-Posterioris-Estimate-MAPE><a title="Maximum a Posterioris Estimate(MAPE)" class=headerlink href=#Maximum-a-Posterioris-Estimate-MAPE></a>Maximum <em>a Posterioris</em> Estimate(MAPE)</h3><p>$\quad$With the two parts of knowledge in mind,we are well ready to get our hands on Maximum <em>a posterioris</em>!<br>$\quad$As its name suggests,<em>a posterioris</em> means after.Then estimating based on prior tests is the core of this method.<br>$\quad$We define a set of tests $S$,and the desired possibility of the event $\theta$ is happening is defined as<blockquote><p>$P(\theta|S)$</blockquote><p>$\quad$According to the Bayes’ theorem,the possibility above can be described as<blockquote><p>$P(\theta|S)=\frac{P(S|\theta)P(\theta)}{P(S)}$</blockquote><p>$\quad$Obviously,the $P(S|\theta)$ refers to the <em>most likelihood</em> function $L(\theta)$.Easily,we can calculate the MAP possibility.<h2 id=Abstract><a class=headerlink href=#Abstract title=Abstract></a>Abstract</h2><p>simplifying calculations will cost performance quality?<br>utilizing <em>trusted</em> incoming messages with <em>a priori</em> messages for updates.<br>proposed two strategies:<blockquote><p>symbol-based truncation(ST)(基于特征的去杂)<br>edge-based simplification(ES)(基于边缘的简化)<br>conveniently tuning parameters can make great trade-off between performance and complexity</blockquote><h2 id=Introduction><a class=headerlink href=#Introduction title=Introduction></a>Introduction</h2><p>$\quad$MIMO enables high spectrum-efficiency and energy-efficiency.<br>$\quad$Current <em>maximum a posteriori</em> (MAP) detection(最大后验检测) or the <em>maximum likelihood</em> detection(极大似然检测) can achieve minimum error probability while costing exponential complexity with modulation order and MIMO scale.<br>$\quad$Sphere decoder(SD) restricts candidate symbols to ones within a sphere (depth first) or a list of size $K$ (width first).It performs well in small-size MIMO, while for large-scale MIMO it suffers cubic($\mathcal{O}^3$) time complexity.<br>$\quad$For large-scale MIMO,linear detectors like <em>zero-forcing</em>(ZF) detector or <em>linear minimum mean square error</em>(LMMSE) detector are often applied,performing way worse than the previous methods.<br>$\quad$Another problem is the matrix inversion,bringing excessive complexity.Even new methods like the <em>Neumann series approximation</em> can’t fully exploit the MIMO benefits.<br>$\quad$<em>Finally</em>,the Belief Propagation(BP)detector based on the Bayes’ tule is proposed.It can delever near-optimal performance and holds a soft-input soft-output character.And it can be easily applied to various hardware and scaled for applications.<br>$\quad$The BP method achieves near-optimal when in small-to medium MIMO but costs exponentially increasing complexity.<br>$\quad$The work in this paper focuses on both reducing the complexity and maintaining performance.<!--So far, the design of efficient MIMO BP detectors remains challenging. First, the existing
 BP detectors suffer an aggravated performance error floor in relatively high signal-to-noise ratio
 (SNR) region, due in part to the well-known impact of the inherent loopy structure for the full
connected FG model [23], in part to the approximations such as GAI. Second, the complexity of
 existing BP detectors is still high and not flexible enough for various applications. These multiple
 challenges motivate us(us?) to think of an approach which can reduce the detection complexity while
 mitigating the error floor towards better performance.--><p>$\quad$This aim is mainly achieved by introducing the Belief-selective Propagation(BsP),utilizing <em>a priori</em> (AP) probabilities to update incoming messages to output messages.This approach avoids propagating “low belief” messages.<h2 id=Preliminaries><a class=headerlink href=#Preliminaries title=Preliminaries></a>Preliminaries</h2><p>$N_t,N_r$ denote FN number and SN number(implying $N_r$ messages).<h3 id=System-Model><a title="System Model" class=headerlink href=#System-Model></a>System Model</h3><p>QAM:Quadrature Amplitude Modulation<br>$s=[s_1,s_2,…,s_N{_t}]^T$<br>The flat-fading complex MIMO channel matrix $\mathbf {H}$ is a $N_r\times N_t$ matrix:<blockquote><p>$\mathbf {H}=[\mathbf {h_1}^{T},\mathbf {h_2}^{T},…\mathbf {h_{N_r}^{T}}]^T$</blockquote><p>where each component $\mathbf {h_i}$ is a complex channel coefficient.<br><!--is a complex channel coefficient following the zero-mean and unit-variance Gaussian distribution
 Why this is less unlikely to happen in the future communication?--><h3 id=BP-Detection-With-the-FG-Model><a title="BP Detection With the FG Model" class=headerlink href=#BP-Detection-With-the-FG-Model></a>BP Detection With the FG Model</h3><p>$\quad$In a <em>factor graph</em>(FG) model,there are two types of nodes,namely <em>factor node</em>(FN) and <em>symbol node</em>(SN),denoted in graphs as:<br>$\begin{cases}f_i \Leftrightarrow FN, & i\in {1,2,…,N_r} \ S_j\Leftrightarrow SN, & j\in {1,2,…,N_t}\end{cases}$<br>$\quad$In both the factor graph and the tanner graph,we use the channel matrix $\mathbf {H}$ to denote elements. To be exact,each $f_i$ corresponds to the $i$-th row of the channel matrix,and each $S_j$ relates to the $j$-th column of the channel matrix. Every pair<br>of $f_i$ and $S_j$ are connected with an edge corresponding to the channel coefficient $h_{ij}$.<br>$\quad$In this article ,message $\beta_{ij}$ will be delivered from $f_i$ to $S_j$,while the message $\alpha$ will be computed and transferred in a reverse direction,meaning $\alpha_{ji}$ will be message sent from $S_j$ to $f_i$.<h2 id=The-Proposed-BsP-Detection><a title="The Proposed BsP Detection" class=headerlink href=#The-Proposed-BsP-Detection></a>The Proposed BsP Detection</h2><p>$\quad$The constellation cardinality($|(\mathcal A)|$) of the MIMO systems and the degree<!--?--> of the function nodes(FNs) contribute greatly to the exponential computational complexity.<br>$\quad$However symbol vectors with low reliability contribute limitly to the message $\beta_{ij}$,encouraging us to squeeze the search space by removing them.<!-- 1)STstrategy to reduce thecardinalityof the
 transmittedsymbol
  2)ESstrategy tosimplified theconnected
 edgesof theFNs--><p><strong>$\quad$The two strategies can be concluded in a simple metaphor.Here comes a bunch of people $\alpha_{ji}$,with $j\in \mathbf{k}$,each with a number of messages.Based on the credibility of each person,you select $d_f$ most credible people to receive message,being the ES strategy.For each independent person, you select $d_m$ most credible messages to hear,being the ST strategy.</strong><h3 id=Symbol-Based-Truncation-Strategy><a title="Symbol-Based Truncation Strategy" class=headerlink href=#Symbol-Based-Truncation-Strategy></a>Symbol-Based Truncation Strategy</h3><p><strong>Here,this ST strategy can be simply described in a sentence:Man</strong><br>$\quad$Incoming $\alpha_{ji}{}$ is truncated into $\alpha_{ji}^{t}$ by eliminating the <em>log-likelihood ratio</em>(LLR) with relatively small value.<br>$\quad$Formula unheard of to compute message $\beta_{ij}$.With $\mu_k$ and $\mu_1$,I think this in part looks like the <strong>LLR</strong>?<br>$\quad$Core is to eliminate low credibility incoming data $\alpha$ into $\alpha^t$(truncated).This procedure is basesd on the LLR.<br>$\quad$In this paper,this method(ST) successfully made it to reduce the number of possible choices of transmitted symbols to:<blockquote><p>$\psi_{ST}=|\mathcal A|\times |\mathcal B(d_m)|$</blockquote><p>where $\mathcal B(d_m)$ denotes the configuration set of possible choices of $\mathbf{s_k}_{\backslash j}$,with $|\mathcal B(d_m)|=(d_m)^{(N_t-1)}$<br>Because $d_m << |\mathcal A|$,the ST strategy reduces the computaional complexity.<h3 id=Edge-Based-Simplification-Strategy><a title="Edge-Based Simplification Strategy" class=headerlink href=#Edge-Based-Simplification-Strategy></a>Edge-Based Simplification Strategy</h3><p>Apart from the ST strategy,the ES strategy further reduces the computational complexity.<br>The core if it is to directly decide some of the transmitted symbol $\mathbf {s_{k}}_{\backslash j}$.<br>By choosing the most reliable message (judging by LLR),we can denote the new configuration set as$\mathcal B(|\mathcal A|,d_f)$:<blockquote><p>$\mathcal B(|\mathcal A|,d_f)={ {\mathbf{s_k}_ {\backslash j} }=[\mathbf { {s_k} }<em>{\backslash j,d_f};\mathbf {\bar{s_k}</em>{\backslash j,d_f}^T]} }$</blockquote><p>In this sense,the cardinality of $\mathcal B(|\mathcal A|,d_f)$ is<blockquote><p>$|\mathcal B(|\mathcal A|,d_f)|=\binom{N_t-1} {d_f-1}|\mathcal A|^{d_f-1}$</blockquote><p>and the number of possible choices are reduced by the ES strategy to:<blockquote><p>$\psi_{ES}=|\mathcal A|\times \binom{N_t-1} {d_f-1}|\mathcal A|^{d_f-1}$</blockquote><h3 id=Initialization-with-PP-Information><a title="Initialization with PP Information" class=headerlink href=#Initialization-with-PP-Information></a>Initialization with PP Information</h3><p>Core algorithm:LMMSE(Linear Minimum Mean Square Estimate).<blockquote><p>$\hat{\mathbf s}_{\text{MMSE} }=(\mathbf{H}^H\mathbf H+\sigma^2\mathbf{I})^{-1}\mathbf{H}^H\mathbf{y}$.</blockquote><p>Where we denote:<blockquote><p>$$\mathbf{K}=(\mathbf H^H\mathbf H+\sigma^2\mathbf{I})^{-1}$$</blockquote><p>With such,<em>a priori</em> probabilities of transmitted symbols are computed by<blockquote><p>$p_j(\mu_k) = \exp {-\frac{||\mu_k - \hat{\mathbf{s}}{\text{MMSE}}||^2}{2\sigma{\text{MMSE}_j}^2} }$</blockquote><h3 id=The-Proposed-BsP-Detector><a title="The Proposed BsP Detector" class=headerlink href=#The-Proposed-BsP-Detector></a>The Proposed BsP Detector</h3><h4 id=Algorithm-of-the-BsP-Detection><a title="Algorithm of the BsP Detection" class=headerlink href=#Algorithm-of-the-BsP-Detection></a>Algorithm of the BsP Detection</h4><p>This is a rather interesting algorithm!<br>Input:received signal $\mathbf y$ and channel matrix $\mathbf H$<br>Output:soft information of coded bits $\mathbf r$<h2 id=Appendix><a class=headerlink href=#Appendix title=Appendix></a>Appendix</h2><p>PP: pseudo priori<br>(|$\mathcal A$|): constellation cardinality<br>LLR: log-likelihood ratio<br>AMI: average mutual information<br>BER: bit error rate or block error rate(误码率和误信率)</div><footer class=post-footer><div class=post-tags><a href=/tags/Reading-Paper/ rel=tag># Reading-Paper</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a title="Reading Paper:factor graphs and the sum product algorithm" href=/2024/07/14/Reading-Paper-factor-graphs-and-the-sum-product-algorithm/ rel=next> <i class="fa fa-chevron-left"></i> Reading Paper:factor graphs and the sum product algorithm </a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a title="compensation:KL divergence" href=/2024/07/15/compensation-KL-divergence/ rel=prev> compensation:KL divergence <i class="fa fa-chevron-right"></i> </a></div></div></footer></div></article><div class=post-spread></div></div></div><div class=comments id=comments><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=noopener target=_blank>comments powered by Disqus.</a></noscript></div></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class=sidebar id=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录<li class=sidebar-nav-overview data-target=site-overview-wrap>站点概览</ul><section class="site-overview-wrap sidebar-panel"><div class=site-overview><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt class=site-author-image itemprop=image src=/images/avatar.png><p class=site-author-name itemprop=name><p class="site-description motion-element" itemprop=description></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>15</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-tags"><a href=/tags/index.html> <span class=site-state-item-count>2</span> <span class=site-state-item-name>标签</span> </a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item> <a href=https://github.com/JohnnyZhu035 target=_blank title=GitHub> <i class="fa fa-fw fa-github"></i></a> </span><span class=links-of-author-item> <a href=213232918@seu.edu.cn target=_blank title=E-Mail> <i class="fa fa-fw fa-envelope"></i></a> </span></div></div></section><!--noindex--><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#Prerequisites><span class=nav-number>1.</span> <span class=nav-text>Prerequisites</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Bayes%E2%80%99-theorem><span class=nav-number>1.1.</span> <span class=nav-text>Bayes’ theorem</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Maximum-Likelihood-Estimate-MLE><span class=nav-number>1.2.</span> <span class=nav-text>Maximum Likelihood Estimate(MLE)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Maximum-a-Posterioris-Estimate-MAPE><span class=nav-number>1.3.</span> <span class=nav-text>Maximum a Posterioris Estimate(MAPE)</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Abstract><span class=nav-number>2.</span> <span class=nav-text>Abstract</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Introduction><span class=nav-number>3.</span> <span class=nav-text>Introduction</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Preliminaries><span class=nav-number>4.</span> <span class=nav-text>Preliminaries</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#System-Model><span class=nav-number>4.1.</span> <span class=nav-text>System Model</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#BP-Detection-With-the-FG-Model><span class=nav-number>4.2.</span> <span class=nav-text>BP Detection With the FG Model</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#The-Proposed-BsP-Detection><span class=nav-number>5.</span> <span class=nav-text>The Proposed BsP Detection</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Symbol-Based-Truncation-Strategy><span class=nav-number>5.1.</span> <span class=nav-text>Symbol-Based Truncation Strategy</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Edge-Based-Simplification-Strategy><span class=nav-number>5.2.</span> <span class=nav-text>Edge-Based Simplification Strategy</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Initialization-with-PP-Information><span class=nav-number>5.3.</span> <span class=nav-text>Initialization with PP Information</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#The-Proposed-BsP-Detector><span class=nav-number>5.4.</span> <span class=nav-text>The Proposed BsP Detector</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Algorithm-of-the-BsP-Detection><span class=nav-number>5.4.1.</span> <span class=nav-text>Algorithm of the BsP Detection</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Appendix><span class=nav-number>6.</span> <span class=nav-text>Appendix</span></a></ol></div></div></section><!--/noindex--><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div></aside></div></main><footer class=footer id=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-user"></i> </span><span class=author itemprop=copyrightHolder>Johnny</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-area-chart"></i> </span><span title=站点总字数>NaNm</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点总阅读次数>NaN:aN</span></div><div class=theme-info>主题 — <a class=theme-link href=https://github.com/theme-next/hexo-theme-next target=_blank>NexT.Pisces</a> v6.0.0</div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("7/10/2024 0:00:00"); //修改为你的网站开始运行的时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "这个网站已经上了这么多天班了 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);</script></div></footer></div><script>if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }</script><script src=/lib/jquery/index.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/js/src/utils.js></script><script src=/js/src/motion.js></script><script src=/js/src/affix.js></script><script src=/js/src/schemes/pisces.js></script><script src=/js/src/scrollspy.js></script><script src=/js/src/post-details.js></script><script src=/js/src/bootstrap.js></script><script async id=dsq-count-scr src=https://johnnyzhuswebsite.disqus.com/count.js></script><script>var disqus_config = function () {
          this.page.url = 'https://johnnyzhu035.github.io/2024/07/14/Reading-Paper-Belief-selective-Propagation-Detection-for-MIMO-systems/';
          this.page.identifier = '2024/07/14/Reading-Paper-Belief-selective-Propagation-Detection-for-MIMO-systems/';
          this.page.title = 'Reading Paper:Belief-selective Propagation Detection for MIMO Systems';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://johnnyzhuswebsite.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);</script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type=text/x-mathjax-config>
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script src=https://cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML></script>